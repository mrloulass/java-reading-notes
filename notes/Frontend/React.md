# React
- is a library for performing efficient updates to a web page, a process referred to as `rendering`. To use React, the author describes how a given application state should be displayed and React takes care of manipulating the browser's DOM to match that shape.
## One-Way vs. Two-Way Data Flow
- React embraces the concept of `one-way data flow`
- using React, the view is generated by React, but does not communicate directly back to it. Instead, actions generated by your views such as `clicks` and `key` presses must go through an intermediate layer which React calls the `dispatcher`
-  This `dispatcher` decides how to interpret the action and what changes, if any, should be made to your application state. React documentation refers to the state of your application as the `store`.
- React does not have an opinion on what `dispatcher` and `store` you should use, it only provides the capability to convert your state into updates for the browser. You can write your own `dispatcher` and `store`, or use one of the many options available as open source projects.
## Virtual DOM
- React makes sure that the `render` function's output is what the page actually contains. This may involve adding elements, removing elements, or updating elements in-place.
- To build up a minimal list of operations to be performed on the DOM, React needs to be able to compare what is currently in the DOM to what should be there. To support this, the `render` function does not output HTML or make changes to the DOM directly. Instead, it outputs a data structure known as a `Virtual DOM`. 
- React then checks the virtual DOM against the real DOM in the browser and makes a list of updates to perform. Since DOM manipulation is a slow process, this ensures that only elements that have genuinely changed are updated.
## Frameworks and Libraries
- the terms `framework` and `library`. Both of these terms describe "code someone else wrote that is not part of your application".
  - `library` is a collection of functionality that is meant to be integrated into your application. Each part of a library is relatively isolated and can be brought in piece-by-piece. 
  - `Frameworks`, on the other hand, work by having your application embedded inside them. In this way, frameworks dictate much, if not all, of how your application is structured. 
### Benefits
- `frameworks`, dictates much of how your application will work, they are great at taking shortcuts by providing simpler ways of adding difficult functionality to your projects. It also reduces the amount of work you need to get started on a project.
- `libraries`, on the other hand, don't dictate how they are used. When working on a project, you choose how to bring them into your application and what parts you would like to use. As such, you must hook up all the necessary parts yourself, which often means that getting started with a library is a bit slower.
### Drawbacks
- `frameworks`, decisions are made up front that allow and define the shortcuts to be taken in a project. By doing this, it will restrict the choices you have within your project. Conventions are great until you want to break them, and in some frameworks, stepping outside the dictated path can be quite tricky.
- `Libraries`, however, have very few built-in decisions, so you're at much greater liberty to use it just the way you want to. You can use a single function from a library or use all of what is provided. When using libraries, you also have the option to use multiple libraries together in ways the original authors had no intention of.
### Metaphor
- `framework` is like a workout class. You use the equipment the instructor wants you to use, and you do the exercises the instructor chooses.
  - The workout class is nice because you just show up and put in the work, but you trust that the instructor has put together a reasonable routine.
- `Libraries` is like going to a gym. Having all the machines available to you. You decide what equipment to use and how to use it yourself. 
  - going to the gym and using the available equipment is useful because you get to work on exactly what you want, and for as long as you would like by making up your own workout.
## Terms
- `React`	A library for performing efficient updates to a web page.
- `React.createElement()`	A React method that creates new elements on the page rather than having to add the elements into the index.html file.
- `ReactDOM`	A package needed to render the React.createElement() correctly.
- `render()`	A method included in the ReactDOM package that allows to render elements onto the webpage.
## Rendering with React
- A React Element is the smallest building block in React. The virtual DOM is a tree structure comprised of a root element that contains other elements. This tree of virtual DOM elements is immutable, meaning that it can't be changed after creation. This allows React to keep previous versions of the virtual DOM to compare against when updates are made to help ensure only the minimal amount of work is performed.

### Project Structure
- in public/index.html
```html
<!doctype html>
<html>
    <head>
        <title></title>
    </head>
    <body>
        <div id="root"></div>
        <script src="bundle.js"></script>
    </body>
</html>
```
- `<body>` tag, there is a:
  - `<div>` tag with an `id of root`.  
  - `<script>` tag with `bundle.js` file
    - use `webpack` to bundle all your project's files and dependencies into a single `bundle.js` file. 
    - When you run `npm start` from the project directory, the `webpack` process is started, and it monitors any changes to your files and rebuilds the `bundle.js` file for you. 
    - This means you can add many JavaScript files to your `src` directory and they will all be available in your final page. 
    - you won't be directly working in the `bundle.js` file but in the `index.js` file within the `src folder` within your project
- in src/index
  - To start using React, you need to make sure it has been imported into the `index.js` file
  - `import React from 'react';`
### Create Element
```javascript
import React from 'react';

React.createElement('h1', {}, 'Hello World!');
```
- The `React.createElement()` method is very useful because it creates new elements for you on the page rather than having to add the elements into your `index.html` file.
- `React.createElement()` method takes in three parameters: `type`, `props`, and `children`
  - `type` is the HTML tag you want to create, in this case, an `h1` tag. 
  - `Props` (stands for properties) are `objects` that get added to the element. They can be used to add `class` and `id` names or other `attributes` to the element created. 
  - `Children` are zero or more elements that are nested inside the element. In this case, you are providing some plain text as a child of the `h1` tag.
### ReactDOM
```javascript
import React from 'react';
import ReactDOM from 'react-dom';

ReactDOM.render(
  React.createElement('h1', {}, 'Hello World!'),
  document.getElementById('root')
);
```
- to get React to update the page based on it, you must use the `render` function from the `react-dom` package. 

- add the `render()` function that is included in the ReactDOM package. 
- `render()` has two parameters:
  - The first parameter is what you would like to render on the page.render the React.createElement('h1', {}, 'Hello World!'); 
  - The second parameter is where you would want to render the `createElement()` method. 
    - there is a `<div>` in the HTML file with an `id` of `root`. This is where you are going to render your newly created` h1` element by using `document.getElementById('root')`.
### Props and Children
- use `props` and `children` in the React.createElement() method.
```javascript
import React from 'react';
import ReactDOM from 'react-dom';

ReactDOM.render(
  React.createElement(
    'div',
    {},
    React.createElement('h1', { className: 'flowers' }, 'Hello World!')
  ),
  document.getElementById('root')
);
```
### Attributes between React and HTML
[Attribute names](https://reactjs.org/docs/dom-elements.html)
- used in `React.createElement`,
### [Rendering Elements](https://reactjs.org/docs/rendering-elements.html)
- Elements are the smallest building blocks of React apps.

## JSX
- `JavaScript XML (JSX)` is a new syntax that can be used to make writing `React.createElement` feel more like writing `HTML`. `JSX` is converted to `React.createElement` through a process known as `transpiling`
  - `Transpiling` means taking code written in one language and transforming it into another, similar language
### JSX Syntax for React.createElement
- `React.createElement()`
```javascript
import React from 'react';
import ReactDOM from 'react-dom';

ReactDOM.render(
  React.createElement(
    'div',
    { className: 'flower' },
    React.createElement('h1', {}, 'Hello World!')
  ),
  document.getElementById('root')
);
```
- JSX
```jsx
import React from 'react';
import ReactDOM from 'react-dom';

ReactDOM.render(
  <div className="flower">
    <h1>Hello World!</h1>
  </div>,
  document.getElementById('root')
);
```
### How JSX Works
- Babel takes care of converting the JSX code into JavaScript.
#### What is Babel?
- `Babel` is a JavaScript compiler, and is frequently used with `JSX`. `Babel` is a set or sets of functions that add certain features to projects. In your case of using JSX, there is pre-written code behind the scenes that takes care of the conversion of the JSX code for you. It is important that it isn't magic behind the scenes; there is actual code other programmers have written to make your life easier.
### Using Curly Braces
- you can use any `JavaScrip`t value with your `JSX` by surrounding it with `{` and `}`. The `{}` in `JSX` signify inserting JavaScript including `variables`, `JavaScript expressions`, and calling `functions`
- Instead of having the JSX code within the ReactDOM.render() method, you can set it to a variable and then use the variable within the ReactDOM.render() method
```jsx
import React from 'react';
import ReactDOM from 'react-dom';

const groceryList = (
    <ul>
      <li>Apples</li>
      <li>Oranges</li>
      <li>Mangos</li>
    </ul>
);

ReactDOM.render(
  groceryList,
  document.getElementById('root')
);
```
### Returning JSX From a Function
- You can create functions that produce React elements as well.
```jsx
import React from 'react';
import ReactDOM from 'react-dom';

function groceryList(item1, item2, item3) {
  return (
    <ul>
      <li>{item1}</li>
      <li>{item2}</li>
      <li>{item3}</li>
    </ul>
  );
}

ReactDOM.render(
  groceryList('Apples', 'Oranges', 'Mangos'),
  document.getElementById('root')
);
```
## Components
- component is just a function but instead accepts props (properties) and returns JSX markup. 
- This JSX markup looks and acts like HTML, but it is only `markup`. 
  - `Markup`, in its purest form, is just the different parts of what makes up a webpage.
- the idea of `props`, or `properties`, was used when adding an attribute to a created element. You are going to use this idea by providing an object that contains potentially many fields that you can hand to the HTML.
- Using an object called props instead of parameters in a function is instead called a component. You will then be able to reuse the created component, including the props object and any included fields
- The `props` object is information that is passed to a rendered component and then is passed from parent to child. A parent component is one that controls the entire page and then renders other components that control separate parts of the page.
- You want to convert groceryList() into a component by having an object of props that will hold each of the items. The last thing you have to do to fully convert groceryList() into a component is to capitalize the first letter of the component. This is very important, and when writing a component, it is required that the first letter of the name is capitalized. When using HTML elements, they are always lowercase. Any React components created will always be uppercase because the easiest way for React to tell if it is not an HTML element and is a component is with capitalization.
```jsx
import React from 'react';
import ReactDOM from 'react-dom';

const GroceryList = props => {
  return (
    <ul>
      <li>{props.item1}</li>
      <li>{props.item2}</li>
      <li>{props.item3}</li>
    </ul>
  );
};

ReactDOM.render(
  <GroceryList item1="Apples" item2="Oranges" item3="Mangos" />,
  document.getElementById('root')
);
```
- The item, item2, and item3 properties of the GroceryList component in the render() call are automatically placed within the props parameter object. Each property specified in the render() call is accessed from props using a dot as shown above (e.g., props.item1).
### Stateless Components
- A stateless component is a function and can only display what's in the props object that's passed in â€” there is no state that is maintained (like a class).
### Using a Main Component
- create a main component that contains the data and returns every component within your file. This way, you can render that one, main component and since it returns every other component, you will end up rendering every component you have created.
1. create your main component that you will call `App`, which is a standard name for the main component. App will just be a component that takes in props and returns any components created later on in the file
```jsx
const App = props => {
  return(

  )
}

ReactDOM.render(
  <App/>,
  document.getElementById('root');
)
```
### [Prop Validation](https://reactjs.org/docs/typechecking-with-proptypes.html)
```jsx
import React from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types';

const App = props => {
  return (
    <Employee name="Elizabeth" age={27}/>
  )
}

const Employee = props => (
  <ul>
    <li>{props.name}</li>
    <li>{props.age}</li>
    <li>{props.position}</li>
  </ul>
);

Employee.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number.isRequired,
  position: PropTypes.string
}

Employee.defaultProps = {
  position: "employee"
}

ReactDOM.render(<App />, document.getElementById('root'));
```
- ensure that only certain types of data are provided in the props of a component, you can do so by adding prop validation
- `npm install --save prop-types`
- add another import line importing the PropTypes library,
```jsx
Employee.propTypes = {
  name: PropTypes.string,
  age: PropTypes.number,
}
Employee.defaultProps = {
  position: "employee"
}
```
- `propTypes` and `defaultProps` are defined in the same way and help to alleviate any errors that might have occurred if they did not exist.
- Using default props is a way to avoid the isRequired propType since there will always be a value by default so that it will meet the requirement.
- To validate a plain JavaScript object against a certain shape, you use the `shape` function of PropTypes
### Producing JSX from Collections
-  an array you would like to display,
#### Rendering Data With A For Loop
- use a for loop to iterate over the array and display each element.
```jsx
import React from 'react';
import ReactDOM from 'react-dom';

const App = props => {
  return <List items={listItems} />;
};

const items = ['Bread', 'Milk', 'Eggs', 'Tea'];

const listItems = [];

for (let i = 0; i < items.length; i++) {
  listItems.push(<li key={i}>{items[i]}</li>);
}

const List = props => <ul>{props.items}</ul>;

ReactDOM.render(<App />, document.getElementById('root'));
```
- an array of items that includes four items: Bread, Milk, Eggs, and Tea. You also have an empty array of `listItems`. 
- Within your for loop, you iterate through the items array, and as the loop hits each item in the array, it then pushes that item into the listItems array as a `<li>` element. 
- the `<li>` element has a `key` attribute. This is a special string attribute that is needed when creating lists of elements. Setting the key to be the array item the loop is currently iterating over. 
- the `ReactDOM.render()` method renders the App component which then displays the `listItems array`.
#### Rendering Data With The Map Function
- use the `map()` function of an array which accepts as its parameter a `transformation function` that is applied to each element in the array.
  - The `transformation function` has three parameters:
   - `currentValue` - Required. This is the current element in the array to be transformed.
  - `index` - Optional. This is the index of current the element in the array to be transformed.
  - `array` - Optional. This is the array upon which map is called.
```jsx
import React from 'react';
import ReactDOM from 'react-dom';

const App = props => {
  const items = ['Bread', 'Milk', 'Eggs', 'Tea'];
  return <List items={items} />;
};

const List = props => {
  const listItems = props.items.map((item, index) => (
    <li key={index}>{item}</li>
  ));
  return <ul>{listItems}</ul>;
};

ReactDOM.render(<App />, document.getElementById('root'));
```
#### Rendering Objects With The Map Function
- 
```jsx
import React from 'react';
import ReactDOM from 'react-dom';

const App = props => {
  const items = [
    { name: 'Bread', price: 2.35 },
    { name: 'Milk', price: 2.0 },
    { name: 'Eggs', price: 3.15 },
    { name: 'Tea', price: 4.0 }
  ];

  return <List items={items} />;
};

const List = props => {
  const listItems = props.items.map((item, index) => (
    <li key={index}>
      {item.name}: {item.price}
    </li>
  ));

  return <ul>{listItems}</ul>;
};

ReactDOM.render(<App />, document.getElementById('root'));
```
- mapping function now lives within the component rather than outside, which means you have to define props.items.map(). This is more common practice: do some functionality within the component then return markup. You also want any data you are using to live within the main component. That way, all data is in one spot.
### Multiple Components
```jsx
import React from 'react';
import ReactDOM from 'react-dom';

const App = props => {
  const items = [
    { name: 'Bread', price: 2.35 },
    { name: 'Milk', price: 2.0 },
    { name: 'Eggs', price: 3.15 },
    { name: 'Tea', price: 4.0 }
  ];

  return (
    <div>
      <List items={items} />
      <Employee name="Elizabeth" age={27} position="Sales Manager" />
      <GroceryList item1="Apples" item2="Oranges" item3="Mangos" />
    </div>
  );
};

const List = props => {
  const listItems = props.items.map((item, index) => (
    <li key={index}>
      {item.name}: {item.price}
    </li>
  ));

  return <ul>{listItems}</ul>;
};

const Employee = props => (
  <ul>
    <li>{props.name}</li>
    <li>{props.age}</li>
    <li>{props.position}</li>
  </ul>
);

const GroceryList = props => (
  <ul>
    <li>{props.item1}</li>
    <li>{props.item2}</li>
    <li>{props.item3}</li>
  </ul>
);

ReactDOM.render(<App />, document.getElementById('root'));
```
- four components: `App`, `List`, `Employee`, and `GroceryList`.
- The `App` component contains the data that is going to be passed into the following components. 
- The data is presented as an array of objects that is passed into the `List` component. 
- The data for the `Employee` and `GroceryList` components are passed directly within the return statement within the App component. 
- all the components are located within one `<div>` element in the App's return() statement? This is needed because only one root HTML can be returned.
- there is a `ReactDOM.render()` that contains the App component which will then add everything within the App component to the HTML element with the `id` of `root`.
## Component State
### Class-Based Components
- `stateless components` to a `class-based component`
```jsx
import React from 'react';
import ReactDOM from 'react-dom';

const Hello = props => {
  return (
    <div>
      <h1>Hello, {props.name}!</h1>
    </div>
  );
};
```
1. create an ES6 class that extends a React.Component
```jsx
import React from 'react';
import ReactDOM from 'react-dom';

class Hello extends React.Component {}
```
  - the `React.Component` is provided by React and by using it, you are able to use a JavaScript class as a component.
2. Next, you will need to add a `render()` method to the Component. The `render()` method is required when using a class-based component:
```jsx
import React from 'react';
import ReactDOM from 'react-dom';

class Hello extends React.Component {
  render() {}
}
```
3. Next, you will move the body of the Hello component into the render method within a `return()` statement
```jsx
import React from 'react';
import ReactDOM from 'react-dom';

class Hello extends React.Component {
  render() {
    return (
      <div>
        <h1>Hello, {this.props.name}!</h1>
      </div>
    );
  }
}
```
  - `render` function does not have any parameters. `Props` are accessed differently when using full React components and are available as `this.props`

### State
- two types of data that a component handles: `props` and `state`. 
- These two types of data are similar because they are both `JavaScript objects`. 
- The main difference is:
  - `props` are passed to the component (similar to passing in parameters to a function) 
  - `state` is managed within the component (similar to declaring variables within a function). 
- `State` is an object that the component has access to with the ability to read and write data when necessary
```jsx
import React from 'react';
import ReactDOM from 'react-dom';

class BankAccount extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      accountBalance: 25.00
    };
  }
}
```
- When assigning the `state`, the `constructor` ensures the `React.Component` works correctly. The `state` within the above component is used as storage for all the data in your component.
  - Be sure to call `super(props)` before any other statement. Otherwise, `this.props` will be undefined!
```jsx
class BankAccount extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      savings: {
        accountBalance: 1125.00
      },
      checking: {
        accountBalance: 530.64
      }
    };
  }

  render() {
    return (
      <div>
        <h3>Savings Account Balance: ${this.state.savings.accountBalance}</h3>
        <h3>Checking Account Balance: ${this.state.checking.accountBalance}</h3>
      </div>
    );
  }
}
```
  - The `state` can then be accessed within the `render()` method by calling `this.state.propertyName`. The `this` keyword refers to the object itself, `state` refers to your state object, and the `propertyName` (in your case, it is accountBalance) refers to the field within the state object so you can target the value needed. 
  - state can contain many fields within it
#### setState()
- React manages the automatic updating of the DOM when a component's state changes, thats what makes React so great. To ensure that React always re-renders correctly, never directly alter the state of a component.
- `setState()` adds any changes to the component state to a queue and tells React that the component in question is ready to be rendered.
  - When updating the state, you need to use the `setState()` method and the state should never be updated directly, like below:
```jsx
// NEVER DO THIS
this.state.accountBalance = 10000;
```
##### Changing Text
- changing the state of some text.
```jsx
class Text extends React.Component {
  constructor() {
    super();
    this.state = {
      text: 'Hello World!!'
    };
  }

  update(event) {
    this.setState({ text: event.target.value });
  }

  render() {
    return (
      <div>
        <input type="text" onChange={this.update.bind(this)} />
        <h1>{this.state.text}</h1>
      </div>
    );
  }
}
```
- the `update()` method takes in an `event` and resets the text field of your state to now be the value of the property that triggered that event.
- there is now an `input` that has an `onChange` attribute that binds the input to the `update()` method you created.
- The `input` is what will trigger the event, and the state will now be replaced with whatever value is within the input.
##### Increment Numbers
- increment the amount available to the account by clicking on a button. 
```jsx
class BankAccount extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      accountBalance: 2222.22
    };
  }

  increment() {
    this.setState({ accountBalance: this.state.accountBalance + 1 });
  }

  render() {
    return (
      <div>
        <h3>Account Balance: ${this.state.accountBalance}</h3>
        <button onClick={this.increment.bind(this)}>Increase Amount</button>
      </div>
    );
  }
}
```
- create an `increment()` method that takes in the current state and increments the accountBalance by 1. The button within the render() function then calls the increment() method when clicked.
##### Increment by Specific Number
```jsx
import React from 'react';
import ReactDOM from 'react-dom';

const App = props => {
  return <BankAccount />;
};

class BankAccount extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      accountBalance: 2222.22,
      addAmount: 0
    };
  }

  increment() {
    this.setState({
      accountBalance: this.state.accountBalance + parseInt(this.state.addAmount)
    });
  }

  render() {
    return (
      <div>
        <h3>Account Balance: ${this.state.accountBalance}</h3>
        <input
          type="number"
          onChange={event => this.setState({ addAmount: event.target.value })}
          value={this.state.addAmount}
        />
        <button onClick={this.increment.bind(this)}>Increase Amount</button>
      </div>
    );
  }
}
```
- added a new field to your state: `addAmount`. You will now be updating that field when you type in a number within the input field now living in the` render()` method. When the input changes `(onChange)`, it will take in an event and then use `setState()` to update the `addAmount` field to be the value of whatever the user inputted. Then, within the `increment()` method, you are updating the accountBalance field to now include whatever was inputted.
- parseInt function in the increment function above? When the value of the input is extracted, it is a string. To perform mathematical operations using the value, it is first converted to an integer using parseInt.
## Routing
- is conditional rendering based on the state of your application. 
- routing in React is changing what is being rendered based on where you are in the application. 
### Terms
- `react-router-dom`	A built-in React package that helps with routing.
- `<Route />`	Used to map routes within a webpage.
- `<Router />`	Handles the actual routing.
- `<Link />`	Primary component used when navigating a webpage. This component will render a fully accessible anchor tag.
### [React Router](https://reactrouter.com/)
